http://eloquentjavascript.net/

Chapter 1

Values:
numbers
strings
booleans
objects
functions 
Undefined Values

Call for one and you have it. 
Dynamically allocated bits for storing values
If you run out, you'll be able to reassign. 
This is only a problem if you need to create a bunch

Numbers
64 bits to store a number
2^64 different numbers = 18 quintillion

Scientific Notation: 
2.998e8
That is 2.998 x 10^8 = 299,800,000

Arithmetic

+ * / 
% modulo
144 % 12 = 0
314 % 100 = 14

Special Numbers

Infinity & -Infinity
NaN = Not a number
0 / 0 = NaN

Strings

"Double quotes and "
'single quotes are okay'
"consitency is best'

\ is a special character for escaping a string so you can add quotes or special meaning.

"This is the first line\nAnd this is the second"

"A newline character is written like "\n"."

can be expressed:

"A newline character is written like \"\\n\"."

Operators cannot be used on strings except for '+' which will concatenate

"con" + "cat" + "e" + "nate" = "concatenate"

Unary Operators

console.log(typeof 4.5)
// -> number
console.log(typeof "x")
// -> String

Booleans

console.log(3 > 2)
-> True

Strings can be compared in a similar way: 

console.log("Aardvark" < "Zoraster")
-> True

This is based of the Unicode standard

console.log("Itchy" != "Scratchy")
-> True

One Javascript Value that is not equal to itself: NaN

console.log(NaN == NaN)
-> False

Logical Operators

console.log(true && false)
-> false

console.log(true && true)
-> true

&& and
|| or
!= not

? -- Huh? 

Ternary operatory/Conditional operator
kinda like either or...

console.log(true ? 1 : 2);
-> 1
console.log(false ? 1: 2);
-> 2

True will yield the value on the left
False will yield the value on the right

Undefined Values

null and undefined
are essentially interchangeable...

Automatic Type Conversion
gets a little tricky, here are some examples: 

console.log(8 * null)
// → 0
console.log("5" - 1)
// → 4
console.log("5" + 1)
// → 51
console.log("five" * 2)
// → NaN
console.log(false == 0)
// → true

if you want precise comparison use: 
=== or !==
you might consider using these more often as a defensive measure

Short Circuiting of Logical Operators

The || operator will return the value to its left when that can be converted to true and will return the value on its right otherwise
console.log(null || "user")
-> user
console.log("me" || "you")
-> me

&& works the other way around... When the value to its left is something that converts to false it returns that value and otherwise it returns the value on the right. 

The right will only be evaluated when necessary, this is why its called short circuting


Chapter 2

Program Structure

programming - express sentences in meaningful prose

Expressions and Statements

fragment of code that produces a value is called an expression

Put Semi Colons at the end of statements until you learn the subtleties of Javascript

Variables

Interesting metaphor: 
you should imagine variables as tentacles, rather than boxes. They do not contain values:
They grasp them. A program can access only the values that is still has a hold on
When you need to remember something you grow a tentacle to hold on to it or you reattach one of your exisiting tentacles to it. 

Hmmm.. Haven't heard it described like that before, but is a nice way to break it down. 

var luigisDebt = 140;
luigisDebt = luigisDept -35; 
console.log(luigisDept);
-> 105

A single var statement may define multiple variables. 
The definitions must be seperated by commas

Keywords and Reserved Words

Full list of keywords: 

break case catch class const continue debugger
default delete do else enum export extends false
finally for function if implements import in
instanceof interface let new null package private
protected public return static super switch this
throw true try typeof var void while with yield

The Environment

When a program starts up the environment contains everything that the language uses

Functions

Functions are pieces of a program wrapped in a value. 
The tentacle grasps another piece of code. 
Executing a function is called
invoking, calling, or applying

alert("Good Morning")

The console.log function

var x = 30;
console.log("the value of x is", x)

Return Values

console.log(Math.max(2, 4));
// -> 4

A function 'returns' a value. Anything that produces a value is an expression in JavaScript

console.log(Math.min(2,4) + 100);
// -> 102

Prompt and Confirm

confirm("Shall we, then?");
prompt("Tell me everything you know.", "...");

These functions aren't common as much anymore, but they are good for learning and experiments

Control Flow

var theNumber = Number(prompt("Pick a number", ""));
alert("Your number is the square root of " +
      theNumber * theNumber);
	  
This is an example of straight control flow. 

Conditional Execution

Think of a fork in the road, but they both can lead to the same place in the end. 

var theNumber = Number(prompt("Pick a number", ""));
if (!isNaN(theNumber))
  alert("Your number is the square root of " +
        theNumber * theNumber);

IF + ELSE

var theNumber = Number(prompt("Pick a number", ""));
if (!isNaN(theNumber))
  alert("Your number is the square root of " +
        theNumber * theNumber);
else
  alert("Hey. Why didn't you give me a number?");
  
  
IF + ELSE IF + ELSE

var num = Number(prompt("Pick a number", "0"));

if (num < 10)
  alert("Small");
else if (num < 100)
  alert("Medium");
else
  alert("Large");
 
While and Do Loops

console.log(0);
console.log(2);
console.log(4);
.
.
console.log(n*2);

this is tedious so we use... while loops 

var result = 1;
var counter = 0;
while (counter < 10) {
  result = result * 2;
  counter = counter + 1;
}
console.log(result);
// → 1024

Do is very similar to while, except it will run through its body at lease once before checking the condition. 
This can be helpful for collecting info. 

do {
  var name = prompt("Who are you?");
} while (!name);
console.log(name);

Indenting Code

2 or 4 spaces is the standard. 2 looks pretty good. 
Indentation is not necessary however, as long as your semicolons are in the right space

For Loops

Because while (counter > some value) is so common, for loops provide a shorter and more comprehensive form

for (var number = 0; number <= 12; number = number + 2)
  console.log(number);
  
 The paranteses after a for keyword must contain two semicolons. 
 for (initializes the loop; checks whether the loop must continue; updates the state of the loop AFTER every iteration)
 
 var result = 1;
for (var counter = 0; counter < 10; counter = counter + 1)
  result = result * 2;
console.log(result);
// → 1024

Breaking out of a Loop

break...
immediately jumps out of the enclosing loop. 

This program finds the first number that is greater than or equal to 20 and divisible by 7. 

for (var current = 20; ; current++) {
  if (current % 7 == 0)
    break;
}
console.log(current);
// → 21

Added a little program for solving primes, because I was curious. 

Definitely not eloquent, but it works!

Continue is similar to break, but will just hop to the next iteration of the loop. 

Updating Variables Succinctly

counter = counter + 1;

counter += 1;

counter -= 1; count down

for (var number = 0; number <= 12; number += 2)
	console.log(number);

Dispatching on a value with Swtich

Switch(prompt("What is the weather like")) {
	case "rainy":
		console.log("Remember to bring an umbrella"):
	case "sunny":
		console.log("Dress Lightly");
	case "cloudy":
		console.log("Go outside");
		break;
	default:
		console.log("Unkown weather type!);
		break;
}

fuzzyLittleTurtle is the common way to use capitalization for values
Number (first letter capitalized) is common for constructors. 

Comments

// This will not be executed

or 

/*
This will not be executed
*/
	
  
CHAPTER 3
FUNCTIONS

Functions are the bread and butter of JavaScript programming. 

var square = function(x){
	returns x * x;
};

Functions have a set of parameters. And a body. 
Function body must always be wrapped in braces. 

A function can have multiple parameters or no parameters at all. 

Some functions return, and some functions only have side effects. 
Like makeNoise

Parameters and Scopes

But their initial values are given by the caller of the function
Not the code in the function itself. 
Initial values are given by the caller of the function. 

Variables created inside them, including their parameters are local to the function. 
This means.. The result variable in the power example will be newly created every time the function is called. 
the seperate incantations do not interfere with each other. 

This 'localness' appliess to the parameters and variables declared with the var keyword 
inside the function body. 

Outside of these functions are called global. 

Good example: 

by treating function-local variables as only existing within the function by distinugishing them with var. 
This makes it possible to read and understand functions as small universes, without having to worry about all the code at once. 

Nested Scope

Javascript Distinguishes not just between global and local variables. Function can be created inside other functions, producing several degress of locality.

For example this nonsensical function has two functions inside of it:

var landscape = function() {
	var result = "";
	var flat = function(size){
		for (var count = 0; count < size; count++)
			result += "'";
		result += "\\"
	};
	flat (3)
	mountain(4);
	flat(6);
	mountain(1)
	flat(1);
	return result;
};

lexical scoping. 
Each scope can also see all the local scopes that contain it. 
Each local scope can also see all the local scopes that contain it. 
Ahh that's crazy. 
Functions are the only things that create a new scope
You are allowed to use free-standing blocks. 

var something = 1;
{
	var something = 2;
	// do stuff with variable something
}
// Outside of the block again. 

Functions as values

Function variables usually simple act as names for a specific piece of the program. Such a variable is defined once and never changed. This makes it easy to start confusing the function and its name. 
But the two are different. A function value can do all the things that other values can do - you can use it in arbitrary expressions, not just call it. It is possible to store a funciton value in a new place, pass it as an argument to a function and so on. Similarly, a variable that holds a function is still just a regular variable and can be assisgned a new value, like so: 

var launchMissiles = function(value) {
	missleSystem.launch("now");
};
if (safeMode)
	launchMissles = function(value) {/* Do nothing */};



Declaration Notation

There is a slightly shorter way to say "var square = function" The function keyword can also be used at the start of a statement, as in the following: 
function square(x){
	return x * x;
}

This is a function declaration. The statement defines the variable square and points it at the given function. So far so good. There is one subtelty with this form of function definition, however. 

console.log("The future says:", future());

function future(){
	return "WE STILL HAVE NO FLYING CARS";
}

This code works even though the function is defined below the code that uses it. This is because function declarations are not part of the regular top-to-bottom flow of control. They are conceptually moved to the top of their scope and can be used by all the code in that scope. This is sometimes useful because it gives us the freedom to order code in a way that seems meaningful, without worrying about having to define all functions above their first use. 

What happens when you put such a function definition inside a conditional (if) block or a loop?
Well, don't do that. Different JavaScript platforms in different browsers have traditionally done different things in that situation, and the latest standard actually forbids it. If you want your programs to behave consistently, only use this form of function-defining statements in the outermost block of a function or program. 

function example(){
	function a() {}
	if (something) {
		function b() {} // danger!!!
	}
}

THE CALL STACK

It will be helpful to take a closer look at the way control flows through functions. Here is a simple program that makes a few function calls: 

function greet(who) {
	console.log("Hello" + who);
}
greet("Harry");
console.log("Bye");

A run through this program goes roughly like this: the call to greet causes control to jump to the start of that function (line 2). It calls console.log(a built-in browser function), which takes control, does its job, and then returns control to line 2. Then it reaches the end of the greet function, so it returns to the place that called it, at line 4. The line after that calls console.log again.

We could show the flow control schematically like this: 

top
	greet
		console.log
	greet
top
	console.log
top

Because a function has to jump back to the place of the call when it returns the computer must remember the context from which the function was called. In one case, console.log has to jump back to the greet function. In the other case, it jumps back to the end of the program. 

The place where the computer stores this context is the call stack. Every time a function is called, the current context is put on top of the "stack". When the function returns, it removes the top context from the stack and uses it to continue execution. 
Storing this stack requires space in the computer's memory. When the stack grows too big, the computer will fail with a message like "out of stack space" or "too much recursion" The following code illustrates this by asking the computer a really hard question, which causes an infinite back-and-forth between two functions. Rather, it would be infinite if the computer had an infinite stack. As it is, we will run out of space, or "blow the stack". 

function chicken(){
	return egg();
}
function egg(){
	return chicken();
}

console.log(chicken() + " came first.");

OPTIONAL ARGUMENTS

the following code is allowed and executes without any problem: 

alert("Hello", "Good Evening", "How do you do?");

The function alert officially accepts only one argument. Yet when you call it like this, it doesn't complain. It simply ignores the other arguments and show you "Hello".

JavaScript is extremely broad-minded about the number of arguments you pass to a function. If you pass too many, the extra ones are ignored. If you pass too few, the missing parameters simply get assigned the value undefined. 

The downside of this is that it is possible- likely even - that you'll accidentally pass the wrong number of arguments to functions and no one will tell you about it. 

The upside is that this behavior can be used to have a function take "optional" arguments. For example, the following version of power can be called either with two arguments or with a single argument, in which case the exponent is assumed to be two, and the function behaves like square. 

function power(base, exponent) {
	if (exponent == undefined)
		exponent = 2;
	var result = 1;
	for (var count = 0; count < exponent; count++){
		result *= base;
	return result;
}

console.log(power(4));

console.log(power(4, 3));